/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.3.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { AppSettingApiUrl } from 'src/app/common/config/app-config';

//export const AppSettingApiUrl = new InjectionToken<string>('AppSettingApiUrl');

@Injectable()
export class AppMenuClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(AppSettingApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    appMenu(id: number): Observable<GetMenuByIdResponse> {
        let url_ = this.baseUrl + "/api/AppMenu/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppMenu(<any>response_);
                } catch (e) {
                    return <Observable<GetMenuByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMenuByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAppMenu(response: HttpResponseBase): Observable<GetMenuByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMenuByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMenuByIdResponse>(<any>null);
    }
}

@Injectable()
export class AppSettingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(AppSettingApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    appSetting(id: number): Observable<GetApplicationSettingsResponse> {
        let url_ = this.baseUrl + "/api/AppSetting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppSetting(<any>response_);
                } catch (e) {
                    return <Observable<GetApplicationSettingsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApplicationSettingsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAppSetting(response: HttpResponseBase): Observable<GetApplicationSettingsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetApplicationSettingsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApplicationSettingsResponse>(<any>null);
    }
}

@Injectable()
export class ViewSettingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(AppSettingApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    viewSetting(id: number): Observable<GetViewByIdResponse> {
        let url_ = this.baseUrl + "/api/ViewSetting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewSetting(<any>response_);
                } catch (e) {
                    return <Observable<GetViewByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetViewByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processViewSetting(response: HttpResponseBase): Observable<GetViewByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetViewByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetViewByIdResponse>(<any>null);
    }
}

export class MenuItemAttributeDTO implements IMenuItemAttributeDTO {
    attributeId?: number;
    itemId?: number;
    attributeKey?: string;
    attributeValue?: string;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;

    constructor(data?: IMenuItemAttributeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeId = _data["attributeId"];
            this.itemId = _data["itemId"];
            this.attributeKey = _data["attributeKey"];
            this.attributeValue = _data["attributeValue"];
            this.createdBy = _data["createdBy"];
            this.createdByPersonName = _data["createdByPersonName"];
            this.updatedBy = _data["updatedBy"];
            this.updatedByPersonName = _data["updatedByPersonName"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): MenuItemAttributeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemAttributeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeId"] = this.attributeId;
        data["itemId"] = this.itemId;
        data["attributeKey"] = this.attributeKey;
        data["attributeValue"] = this.attributeValue;
        data["createdBy"] = this.createdBy;
        data["createdByPersonName"] = this.createdByPersonName;
        data["updatedBy"] = this.updatedBy;
        data["updatedByPersonName"] = this.updatedByPersonName;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IMenuItemAttributeDTO {
    attributeId?: number;
    itemId?: number;
    attributeKey?: string;
    attributeValue?: string;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;
}

export class MenuItemRoleDTO implements IMenuItemRoleDTO {
    itemId?: number;
    roleId?: string;
    normalizedName?: string;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;

    constructor(data?: IMenuItemRoleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.roleId = _data["roleId"];
            this.normalizedName = _data["normalizedName"];
            this.createdBy = _data["createdBy"];
            this.createdByPersonName = _data["createdByPersonName"];
            this.updatedBy = _data["updatedBy"];
            this.updatedByPersonName = _data["updatedByPersonName"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): MenuItemRoleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemRoleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["roleId"] = this.roleId;
        data["normalizedName"] = this.normalizedName;
        data["createdBy"] = this.createdBy;
        data["createdByPersonName"] = this.createdByPersonName;
        data["updatedBy"] = this.updatedBy;
        data["updatedByPersonName"] = this.updatedByPersonName;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IMenuItemRoleDTO {
    itemId?: number;
    roleId?: string;
    normalizedName?: string;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;
}

export class MenuItemDTO implements IMenuItemDTO {
    itemId?: number;
    menuId?: number;
    parentItemId?: number;
    name?: string;
    uri?: string;
    icon?: string;
    routeName?: string;
    isExternalLink?: boolean;
    hasChild?: boolean;
    itemOrder?: number;
    showChildDsp?: boolean;
    isActiveDsp?: boolean;
    childMenuItems?: MenuItemDTO[];
    attributes?: MenuItemAttributeDTO[];
    roles?: MenuItemRoleDTO[];
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;

    constructor(data?: IMenuItemDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.menuId = _data["menuId"];
            this.parentItemId = _data["parentItemId"];
            this.name = _data["name"];
            this.uri = _data["uri"];
            this.icon = _data["icon"];
            this.routeName = _data["routeName"];
            this.isExternalLink = _data["isExternalLink"];
            this.hasChild = _data["hasChild"];
            this.itemOrder = _data["itemOrder"];
            this.showChildDsp = _data["showChildDsp"];
            this.isActiveDsp = _data["isActiveDsp"];
            if (Array.isArray(_data["childMenuItems"])) {
                this.childMenuItems = [] as any;
                for (let item of _data["childMenuItems"])
                    this.childMenuItems!.push(MenuItemDTO.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(MenuItemAttributeDTO.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(MenuItemRoleDTO.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdByPersonName = _data["createdByPersonName"];
            this.updatedBy = _data["updatedBy"];
            this.updatedByPersonName = _data["updatedByPersonName"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): MenuItemDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["menuId"] = this.menuId;
        data["parentItemId"] = this.parentItemId;
        data["name"] = this.name;
        data["uri"] = this.uri;
        data["icon"] = this.icon;
        data["routeName"] = this.routeName;
        data["isExternalLink"] = this.isExternalLink;
        data["hasChild"] = this.hasChild;
        data["itemOrder"] = this.itemOrder;
        data["showChildDsp"] = this.showChildDsp;
        data["isActiveDsp"] = this.isActiveDsp;
        if (Array.isArray(this.childMenuItems)) {
            data["childMenuItems"] = [];
            for (let item of this.childMenuItems)
                data["childMenuItems"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdByPersonName"] = this.createdByPersonName;
        data["updatedBy"] = this.updatedBy;
        data["updatedByPersonName"] = this.updatedByPersonName;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IMenuItemDTO {
    itemId?: number;
    menuId?: number;
    parentItemId?: number;
    name?: string;
    uri?: string;
    icon?: string;
    routeName?: string;
    isExternalLink?: boolean;
    hasChild?: boolean;
    itemOrder?: number;
    showChildDsp?: boolean;
    isActiveDsp?: boolean;
    childMenuItems?: MenuItemDTO[];
    attributes?: MenuItemAttributeDTO[];
    roles?: MenuItemRoleDTO[];
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;
}

export class MenuDTO implements IMenuDTO {
    menuId?: number;
    name?: string;
    menuItem?: MenuItemDTO[];
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;

    constructor(data?: IMenuDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuId = _data["menuId"];
            this.name = _data["name"];
            if (Array.isArray(_data["menuItem"])) {
                this.menuItem = [] as any;
                for (let item of _data["menuItem"])
                    this.menuItem!.push(MenuItemDTO.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdByPersonName = _data["createdByPersonName"];
            this.updatedBy = _data["updatedBy"];
            this.updatedByPersonName = _data["updatedByPersonName"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): MenuDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MenuDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["name"] = this.name;
        if (Array.isArray(this.menuItem)) {
            data["menuItem"] = [];
            for (let item of this.menuItem)
                data["menuItem"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdByPersonName"] = this.createdByPersonName;
        data["updatedBy"] = this.updatedBy;
        data["updatedByPersonName"] = this.updatedByPersonName;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IMenuDTO {
    menuId?: number;
    name?: string;
    menuItem?: MenuItemDTO[];
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;
}

export class GetMenuByIdResponse implements IGetMenuByIdResponse {
    menu?: MenuDTO;
    errorMsg?: string;
    hasError?: boolean;

    constructor(data?: IGetMenuByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menu = _data["menu"] ? MenuDTO.fromJS(_data["menu"]) : <any>undefined;
            this.errorMsg = _data["errorMsg"];
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): GetMenuByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenuByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["errorMsg"] = this.errorMsg;
        data["hasError"] = this.hasError;
        return data; 
    }
}

export interface IGetMenuByIdResponse {
    menu?: MenuDTO;
    errorMsg?: string;
    hasError?: boolean;
}

export class AppSettingDTO implements IAppSettingDTO {
    appId?: number;
    key?: string;
    valueString?: string;
    valueInt?: number;
    valueDecimal?: number;
    valueDateTime?: Date;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;

    constructor(data?: IAppSettingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.key = _data["key"];
            this.valueString = _data["valueString"];
            this.valueInt = _data["valueInt"];
            this.valueDecimal = _data["valueDecimal"];
            this.valueDateTime = _data["valueDateTime"] ? new Date(_data["valueDateTime"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.createdByPersonName = _data["createdByPersonName"];
            this.updatedBy = _data["updatedBy"];
            this.updatedByPersonName = _data["updatedByPersonName"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): AppSettingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["key"] = this.key;
        data["valueString"] = this.valueString;
        data["valueInt"] = this.valueInt;
        data["valueDecimal"] = this.valueDecimal;
        data["valueDateTime"] = this.valueDateTime ? this.valueDateTime.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdByPersonName"] = this.createdByPersonName;
        data["updatedBy"] = this.updatedBy;
        data["updatedByPersonName"] = this.updatedByPersonName;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IAppSettingDTO {
    appId?: number;
    key?: string;
    valueString?: string;
    valueInt?: number;
    valueDecimal?: number;
    valueDateTime?: Date;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;
}

export class GetApplicationSettingsResponse implements IGetApplicationSettingsResponse {
    settings?: AppSettingDTO[];
    errorMsg?: string;
    hasError?: boolean;

    constructor(data?: IGetApplicationSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(AppSettingDTO.fromJS(item));
            }
            this.errorMsg = _data["errorMsg"];
            this.hasError = _data["hasError"];
        }
    }

    static fromJS(data: any): GetApplicationSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetApplicationSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["errorMsg"] = this.errorMsg;
        data["hasError"] = this.hasError;
        return data; 
    }
}

export interface IGetApplicationSettingsResponse {
    settings?: AppSettingDTO[];
    errorMsg?: string;
    hasError?: boolean;
}

export class ViewAttributeDTO implements IViewAttributeDTO {
    viewSchemaAttributeId?: number;
    attributeKey?: string;
    attributeValue?: string;
    attributeType?: string;

    constructor(data?: IViewAttributeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viewSchemaAttributeId = _data["viewSchemaAttributeId"];
            this.attributeKey = _data["attributeKey"];
            this.attributeValue = _data["attributeValue"];
            this.attributeType = _data["attributeType"];
        }
    }

    static fromJS(data: any): ViewAttributeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ViewAttributeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viewSchemaAttributeId"] = this.viewSchemaAttributeId;
        data["attributeKey"] = this.attributeKey;
        data["attributeValue"] = this.attributeValue;
        data["attributeType"] = this.attributeType;
        return data; 
    }
}

export interface IViewAttributeDTO {
    viewSchemaAttributeId?: number;
    attributeKey?: string;
    attributeValue?: string;
    attributeType?: string;
}

export class ColumnDTO implements IColumnDTO {
    columnSchemaId?: number;
    columnName?: string;
    propertyValueName?: string;
    columnType?: string;
    columnEditableType?: string;
    isPrimary?: boolean;
    columnFormat?: string;
    columnWidth?: number;
    isFilterable?: boolean;
    filterType?: string;
    isSortable?: boolean;
    isHidden?: boolean;
    columnOrder?: number;
    isImage?: boolean;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;

    constructor(data?: IColumnDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.columnSchemaId = _data["columnSchemaId"];
            this.columnName = _data["columnName"];
            this.propertyValueName = _data["propertyValueName"];
            this.columnType = _data["columnType"];
            this.columnEditableType = _data["columnEditableType"];
            this.isPrimary = _data["isPrimary"];
            this.columnFormat = _data["columnFormat"];
            this.columnWidth = _data["columnWidth"];
            this.isFilterable = _data["isFilterable"];
            this.filterType = _data["filterType"];
            this.isSortable = _data["isSortable"];
            this.isHidden = _data["isHidden"];
            this.columnOrder = _data["columnOrder"];
            this.isImage = _data["isImage"];
            this.createdBy = _data["createdBy"];
            this.createdByPersonName = _data["createdByPersonName"];
            this.updatedBy = _data["updatedBy"];
            this.updatedByPersonName = _data["updatedByPersonName"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): ColumnDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnSchemaId"] = this.columnSchemaId;
        data["columnName"] = this.columnName;
        data["propertyValueName"] = this.propertyValueName;
        data["columnType"] = this.columnType;
        data["columnEditableType"] = this.columnEditableType;
        data["isPrimary"] = this.isPrimary;
        data["columnFormat"] = this.columnFormat;
        data["columnWidth"] = this.columnWidth;
        data["isFilterable"] = this.isFilterable;
        data["filterType"] = this.filterType;
        data["isSortable"] = this.isSortable;
        data["isHidden"] = this.isHidden;
        data["columnOrder"] = this.columnOrder;
        data["isImage"] = this.isImage;
        data["createdBy"] = this.createdBy;
        data["createdByPersonName"] = this.createdByPersonName;
        data["updatedBy"] = this.updatedBy;
        data["updatedByPersonName"] = this.updatedByPersonName;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IColumnDTO {
    columnSchemaId?: number;
    columnName?: string;
    propertyValueName?: string;
    columnType?: string;
    columnEditableType?: string;
    isPrimary?: boolean;
    columnFormat?: string;
    columnWidth?: number;
    isFilterable?: boolean;
    filterType?: string;
    isSortable?: boolean;
    isHidden?: boolean;
    columnOrder?: number;
    isImage?: boolean;
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;
}

export class ViewDTO implements IViewDTO {
    viewSchemaId?: number;
    viewName?: string;
    viewAttributes?: ViewAttributeDTO[];
    columns?: ColumnDTO[];
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;

    constructor(data?: IViewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viewSchemaId = _data["viewSchemaId"];
            this.viewName = _data["viewName"];
            if (Array.isArray(_data["viewAttributes"])) {
                this.viewAttributes = [] as any;
                for (let item of _data["viewAttributes"])
                    this.viewAttributes!.push(ViewAttributeDTO.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(ColumnDTO.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdByPersonName = _data["createdByPersonName"];
            this.updatedBy = _data["updatedBy"];
            this.updatedByPersonName = _data["updatedByPersonName"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): ViewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ViewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viewSchemaId"] = this.viewSchemaId;
        data["viewName"] = this.viewName;
        if (Array.isArray(this.viewAttributes)) {
            data["viewAttributes"] = [];
            for (let item of this.viewAttributes)
                data["viewAttributes"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdByPersonName"] = this.createdByPersonName;
        data["updatedBy"] = this.updatedBy;
        data["updatedByPersonName"] = this.updatedByPersonName;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IViewDTO {
    viewSchemaId?: number;
    viewName?: string;
    viewAttributes?: ViewAttributeDTO[];
    columns?: ColumnDTO[];
    createdBy?: number;
    createdByPersonName?: string;
    updatedBy?: number;
    updatedByPersonName?: string;
    statusId?: number;
}

export class ViewSettingVM implements IViewSettingVM {
    groupable?: boolean | undefined;
    sortable?: boolean | undefined;
    filterable?: boolean | undefined;
    pageSize?: number | undefined;
    pageSizes?: string[];
    pageable?: boolean | undefined;
    scrollable?: boolean | undefined;
    skip?: number;
    multiSort?: boolean | undefined;

    constructor(data?: IViewSettingVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupable = _data["groupable"];
            this.sortable = _data["sortable"];
            this.filterable = _data["filterable"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["pageSizes"])) {
                this.pageSizes = [] as any;
                for (let item of _data["pageSizes"])
                    this.pageSizes!.push(item);
            }
            this.pageable = _data["pageable"];
            this.scrollable = _data["scrollable"];
            this.skip = _data["skip"];
            this.multiSort = _data["multiSort"];
        }
    }

    static fromJS(data: any): ViewSettingVM {
        data = typeof data === 'object' ? data : {};
        let result = new ViewSettingVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupable"] = this.groupable;
        data["sortable"] = this.sortable;
        data["filterable"] = this.filterable;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.pageSizes)) {
            data["pageSizes"] = [];
            for (let item of this.pageSizes)
                data["pageSizes"].push(item);
        }
        data["pageable"] = this.pageable;
        data["scrollable"] = this.scrollable;
        data["skip"] = this.skip;
        data["multiSort"] = this.multiSort;
        return data; 
    }
}

export interface IViewSettingVM {
    groupable?: boolean | undefined;
    sortable?: boolean | undefined;
    filterable?: boolean | undefined;
    pageSize?: number | undefined;
    pageSizes?: string[];
    pageable?: boolean | undefined;
    scrollable?: boolean | undefined;
    skip?: number;
    multiSort?: boolean | undefined;
}

export class GetViewByIdResponse implements IGetViewByIdResponse {
    result?: ViewDTO;
    viewSetting?: ViewSettingVM;

    constructor(data?: IGetViewByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ViewDTO.fromJS(_data["result"]) : <any>undefined;
            this.viewSetting = _data["viewSetting"] ? ViewSettingVM.fromJS(_data["viewSetting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetViewByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetViewByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["viewSetting"] = this.viewSetting ? this.viewSetting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetViewByIdResponse {
    result?: ViewDTO;
    viewSetting?: ViewSettingVM;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}