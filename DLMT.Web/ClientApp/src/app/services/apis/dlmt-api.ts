/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.3.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { DlmtApiUrl } from 'src/app/common/config/app-config';

//export const DlmtApiUrl = new InjectionToken<string>('DlmtApiUrl');

@Injectable()
export class AgencyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    all(body: AgencyGetAllRequest | undefined): Observable<AgencyGetAllResponse> {
        let url_ = this.baseUrl + "/api/Agency/fetch/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<AgencyGetAllResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgencyGetAllResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<AgencyGetAllResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgencyGetAllResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgencyGetAllResponse>(<any>null);
    }

    /**
     * @return Success
     */
    fetch(id: number): Observable<AgencyGetByIdResponse> {
        let url_ = this.baseUrl + "/api/Agency/fetch/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetch(<any>response_);
                } catch (e) {
                    return <Observable<AgencyGetByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgencyGetByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFetch(response: HttpResponseBase): Observable<AgencyGetByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgencyGetByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgencyGetByIdResponse>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<AgencyDeleteByIdResponse> {
        let url_ = this.baseUrl + "/api/Agency/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<AgencyDeleteByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgencyDeleteByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<AgencyDeleteByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgencyDeleteByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgencyDeleteByIdResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: AgencyUpdateRequest | undefined): Observable<AgencyUpdateResponse> {
        let url_ = this.baseUrl + "/api/Agency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AgencyUpdateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgencyUpdateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AgencyUpdateResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgencyUpdateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgencyUpdateResponse>(<any>null);
    }
}

@Injectable()
export class CaseTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    all(body: CaseTypeGetAllRequest | undefined): Observable<CaseTypeGetAllResponse> {
        let url_ = this.baseUrl + "/api/CaseType/fetch/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<CaseTypeGetAllResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CaseTypeGetAllResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<CaseTypeGetAllResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypeGetAllResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypeGetAllResponse>(<any>null);
    }

    /**
     * @return Success
     */
    fetch(id: number): Observable<CaseTypeGetByIdResponse> {
        let url_ = this.baseUrl + "/api/CaseType/fetch/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetch(<any>response_);
                } catch (e) {
                    return <Observable<CaseTypeGetByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CaseTypeGetByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFetch(response: HttpResponseBase): Observable<CaseTypeGetByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypeGetByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypeGetByIdResponse>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<CaseTypeDeleteByIdResponse> {
        let url_ = this.baseUrl + "/api/CaseType/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<CaseTypeDeleteByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CaseTypeDeleteByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<CaseTypeDeleteByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypeDeleteByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypeDeleteByIdResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CaseTypeUpdateRequest | undefined): Observable<CaseTypeUpdateResponse> {
        let url_ = this.baseUrl + "/api/CaseType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CaseTypeUpdateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CaseTypeUpdateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CaseTypeUpdateResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypeUpdateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypeUpdateResponse>(<any>null);
    }
}

@Injectable()
export class ContactClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    all(body: ContactGetAllRequest | undefined): Observable<ContactGetAllResponse> {
        let url_ = this.baseUrl + "/api/Contact/fetch/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<ContactGetAllResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactGetAllResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<ContactGetAllResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactGetAllResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactGetAllResponse>(<any>null);
    }

    /**
     * @return Success
     */
    fetch(id: number): Observable<ContactGetByIdResponse> {
        let url_ = this.baseUrl + "/api/Contact/fetch/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetch(<any>response_);
                } catch (e) {
                    return <Observable<ContactGetByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactGetByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFetch(response: HttpResponseBase): Observable<ContactGetByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactGetByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactGetByIdResponse>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<ContactDeleteByIdResponse> {
        let url_ = this.baseUrl + "/api/Contact/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ContactDeleteByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactDeleteByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ContactDeleteByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactDeleteByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDeleteByIdResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ContactUpdateRequest | undefined): Observable<ContactUpdateResponse> {
        let url_ = this.baseUrl + "/api/Contact/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ContactUpdateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactUpdateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContactUpdateResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactUpdateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactUpdateResponse>(<any>null);
    }
}

@Injectable()
export class DeveloperClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    developer(caseNumber: string, phaseNo: string): Observable<DeveloperByPhaseResponse> {
        let url_ = this.baseUrl + "/api/Developer/fetch/developer/{caseNumber}/{phaseNo}";
        if (caseNumber === undefined || caseNumber === null)
            throw new Error("The parameter 'caseNumber' must be defined.");
        url_ = url_.replace("{caseNumber}", encodeURIComponent("" + caseNumber)); 
        if (phaseNo === undefined || phaseNo === null)
            throw new Error("The parameter 'phaseNo' must be defined.");
        url_ = url_.replace("{phaseNo}", encodeURIComponent("" + phaseNo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeveloper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeveloper(<any>response_);
                } catch (e) {
                    return <Observable<DeveloperByPhaseResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeveloperByPhaseResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeveloper(response: HttpResponseBase): Observable<DeveloperByPhaseResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeveloperByPhaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeveloperByPhaseResponse>(<any>null);
    }
}

@Injectable()
export class DlmtCaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    all(body: DlmtCaseGetAllRequest | undefined): Observable<DlmtCaseGetAllResponse> {
        let url_ = this.baseUrl + "/api/DlmtCase/fetch/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<DlmtCaseGetAllResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DlmtCaseGetAllResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<DlmtCaseGetAllResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DlmtCaseGetAllResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DlmtCaseGetAllResponse>(<any>null);
    }

    /**
     * @return Success
     */
    summaryformlookup(): Observable<DlmtNewCaseFormLookupResponse> {
        let url_ = this.baseUrl + "/api/DlmtCase/summaryformlookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummaryformlookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummaryformlookup(<any>response_);
                } catch (e) {
                    return <Observable<DlmtNewCaseFormLookupResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DlmtNewCaseFormLookupResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSummaryformlookup(response: HttpResponseBase): Observable<DlmtNewCaseFormLookupResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DlmtNewCaseFormLookupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DlmtNewCaseFormLookupResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    casesummaryupdate(body: DlmtCaseSummaryUpdateRequest | undefined): Observable<DlmtCaseSummaryUpdateResponse> {
        let url_ = this.baseUrl + "/api/DlmtCase/casesummaryupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCasesummaryupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCasesummaryupdate(<any>response_);
                } catch (e) {
                    return <Observable<DlmtCaseSummaryUpdateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DlmtCaseSummaryUpdateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCasesummaryupdate(response: HttpResponseBase): Observable<DlmtCaseSummaryUpdateResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DlmtCaseSummaryUpdateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DlmtCaseSummaryUpdateResponse>(<any>null);
    }

    /**
     * @return Success
     */
    detailsformlookup(): Observable<DetailsFormLookupResponse> {
        let url_ = this.baseUrl + "/api/DlmtCase/detailsformlookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailsformlookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailsformlookup(<any>response_);
                } catch (e) {
                    return <Observable<DetailsFormLookupResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DetailsFormLookupResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDetailsformlookup(response: HttpResponseBase): Observable<DetailsFormLookupResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DetailsFormLookupResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DetailsFormLookupResponse>(<any>null);
    }

    /**
     * @return Success
     */
    detailsformdata(id: number): Observable<DlmtDetailsFormDataResponse> {
        let url_ = this.baseUrl + "/api/DlmtCase/detailsformdata/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailsformdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailsformdata(<any>response_);
                } catch (e) {
                    return <Observable<DlmtDetailsFormDataResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DlmtDetailsFormDataResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDetailsformdata(response: HttpResponseBase): Observable<DlmtDetailsFormDataResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DlmtDetailsFormDataResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DlmtDetailsFormDataResponse>(<any>null);
    }

    /**
     * @return Success
     */
    personnel(caseNumber: string, phaseNo: string): Observable<DlmtDetailsPersonnelDataResponse> {
        let url_ = this.baseUrl + "/api/DlmtCase/fetch/personnel/{caseNumber}/{phaseNo}";
        if (caseNumber === undefined || caseNumber === null)
            throw new Error("The parameter 'caseNumber' must be defined.");
        url_ = url_.replace("{caseNumber}", encodeURIComponent("" + caseNumber)); 
        if (phaseNo === undefined || phaseNo === null)
            throw new Error("The parameter 'phaseNo' must be defined.");
        url_ = url_.replace("{phaseNo}", encodeURIComponent("" + phaseNo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonnel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonnel(<any>response_);
                } catch (e) {
                    return <Observable<DlmtDetailsPersonnelDataResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DlmtDetailsPersonnelDataResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPersonnel(response: HttpResponseBase): Observable<DlmtDetailsPersonnelDataResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DlmtDetailsPersonnelDataResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DlmtDetailsPersonnelDataResponse>(<any>null);
    }
}

@Injectable()
export class PlanningOfficeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    all(body: PlanningOfficeGetAllRequest | undefined): Observable<PlanningOfficeGetAllResponse> {
        let url_ = this.baseUrl + "/api/PlanningOffice/fetch/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<PlanningOfficeGetAllResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlanningOfficeGetAllResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<PlanningOfficeGetAllResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlanningOfficeGetAllResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlanningOfficeGetAllResponse>(<any>null);
    }

    /**
     * @return Success
     */
    fetch(id: number): Observable<PlanningOfficeGetByIdResponse> {
        let url_ = this.baseUrl + "/api/PlanningOffice/fetch/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetch(<any>response_);
                } catch (e) {
                    return <Observable<PlanningOfficeGetByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlanningOfficeGetByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFetch(response: HttpResponseBase): Observable<PlanningOfficeGetByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlanningOfficeGetByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlanningOfficeGetByIdResponse>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<PlanningOfficeDeleteByIdResponse> {
        let url_ = this.baseUrl + "/api/PlanningOffice/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<PlanningOfficeDeleteByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlanningOfficeDeleteByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<PlanningOfficeDeleteByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlanningOfficeDeleteByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlanningOfficeDeleteByIdResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: PlanningOfficeUpdateRequest | undefined): Observable<PlanningOfficeUpdateResponse> {
        let url_ = this.baseUrl + "/api/PlanningOffice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PlanningOfficeUpdateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlanningOfficeUpdateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PlanningOfficeUpdateResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlanningOfficeUpdateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlanningOfficeUpdateResponse>(<any>null);
    }
}

@Injectable()
export class ReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    adpmain(): Observable<ReportADPMainResponse> {
        let url_ = this.baseUrl + "/api/Report/adpmain";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdpmain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdpmain(<any>response_);
                } catch (e) {
                    return <Observable<ReportADPMainResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportADPMainResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAdpmain(response: HttpResponseBase): Observable<ReportADPMainResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportADPMainResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportADPMainResponse>(<any>null);
    }
}

@Injectable()
export class ZoneAreaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DlmtApiUrl) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    all(body: ZoneAreaGetAllRequest | undefined): Observable<ZoneAreaGetAllResponse> {
        let url_ = this.baseUrl + "/api/ZoneArea/fetch/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<ZoneAreaGetAllResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneAreaGetAllResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<ZoneAreaGetAllResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneAreaGetAllResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneAreaGetAllResponse>(<any>null);
    }

    /**
     * @return Success
     */
    fetch(id: number): Observable<ZoneAreaGetByIdResponse> {
        let url_ = this.baseUrl + "/api/ZoneArea/fetch/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetch(<any>response_);
                } catch (e) {
                    return <Observable<ZoneAreaGetByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneAreaGetByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFetch(response: HttpResponseBase): Observable<ZoneAreaGetByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneAreaGetByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneAreaGetByIdResponse>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<ZoneAreaDeleteByIdResponse> {
        let url_ = this.baseUrl + "/api/ZoneArea/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ZoneAreaDeleteByIdResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneAreaDeleteByIdResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ZoneAreaDeleteByIdResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneAreaDeleteByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneAreaDeleteByIdResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ZoneAreaUpdateRequest | undefined): Observable<ZoneAreaUpdateResponse> {
        let url_ = this.baseUrl + "/api/ZoneArea/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ZoneAreaUpdateResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneAreaUpdateResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ZoneAreaUpdateResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneAreaUpdateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneAreaUpdateResponse>(<any>null);
    }
}

export class FilterCondition implements IFilterCondition {
    filterType?: string | undefined;
    searchKey?: string | undefined;

    constructor(data?: IFilterCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterType = _data["filterType"];
            this.searchKey = _data["searchKey"];
        }
    }

    static fromJS(data: any): FilterCondition {
        data = typeof data === 'object' ? data : {};
        let result = new FilterCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterType"] = this.filterType;
        data["searchKey"] = this.searchKey;
        return data; 
    }
}

export interface IFilterCondition {
    filterType?: string | undefined;
    searchKey?: string | undefined;
}

export class FilterQuery implements IFilterQuery {
    filterOperator?: string | undefined;
    columnName?: string | undefined;
    dataType?: string | undefined;
    conditions?: FilterCondition[] | undefined;

    constructor(data?: IFilterQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterOperator = _data["filterOperator"];
            this.columnName = _data["columnName"];
            this.dataType = _data["dataType"];
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(FilterCondition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new FilterQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterOperator"] = this.filterOperator;
        data["columnName"] = this.columnName;
        data["dataType"] = this.dataType;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFilterQuery {
    filterOperator?: string | undefined;
    columnName?: string | undefined;
    dataType?: string | undefined;
    conditions?: FilterCondition[] | undefined;
}

export class FilterModel implements IFilterModel {
    filterQueries?: FilterQuery[] | undefined;

    constructor(data?: IFilterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["filterQueries"])) {
                this.filterQueries = [] as any;
                for (let item of _data["filterQueries"])
                    this.filterQueries!.push(FilterQuery.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FilterModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.filterQueries)) {
            data["filterQueries"] = [];
            for (let item of this.filterQueries)
                data["filterQueries"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFilterModel {
    filterQueries?: FilterQuery[] | undefined;
}

export class SortCondition implements ISortCondition {
    columnName?: string | undefined;
    sortType?: string | undefined;

    constructor(data?: ISortCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.columnName = _data["columnName"];
            this.sortType = _data["sortType"];
        }
    }

    static fromJS(data: any): SortCondition {
        data = typeof data === 'object' ? data : {};
        let result = new SortCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName;
        data["sortType"] = this.sortType;
        return data; 
    }
}

export interface ISortCondition {
    columnName?: string | undefined;
    sortType?: string | undefined;
}

export class SortModel implements ISortModel {
    sortConditions?: SortCondition[] | undefined;

    constructor(data?: ISortModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sortConditions"])) {
                this.sortConditions = [] as any;
                for (let item of _data["sortConditions"])
                    this.sortConditions!.push(SortCondition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SortModel {
        data = typeof data === 'object' ? data : {};
        let result = new SortModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sortConditions)) {
            data["sortConditions"] = [];
            for (let item of this.sortConditions)
                data["sortConditions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISortModel {
    sortConditions?: SortCondition[] | undefined;
}

export class ViewPredicate implements IViewPredicate {
    startRow?: number;
    endRow?: number;
    filter?: FilterModel;
    sort?: SortModel;

    constructor(data?: IViewPredicate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startRow = _data["startRow"];
            this.endRow = _data["endRow"];
            this.filter = _data["filter"] ? FilterModel.fromJS(_data["filter"]) : <any>undefined;
            this.sort = _data["sort"] ? SortModel.fromJS(_data["sort"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViewPredicate {
        data = typeof data === 'object' ? data : {};
        let result = new ViewPredicate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startRow"] = this.startRow;
        data["endRow"] = this.endRow;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IViewPredicate {
    startRow?: number;
    endRow?: number;
    filter?: FilterModel;
    sort?: SortModel;
}

export class AgencyGetAllRequest implements IAgencyGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IAgencyGetAllRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.predicate = _data["predicate"] ? ViewPredicate.fromJS(_data["predicate"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AgencyGetAllRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyGetAllRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["predicate"] = this.predicate ? this.predicate.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IAgencyGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class AgencyDTO implements IAgencyDTO {
    id?: number;
    name?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IAgencyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): AgencyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IAgencyDTO {
    id?: number;
    name?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class ErrorDTO implements IErrorDTO {
    errorCode?: string | undefined;
    errorType?: string | undefined;
    errorMsg?: string | undefined;

    constructor(data?: IErrorDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.errorType = _data["errorType"];
            this.errorMsg = _data["errorMsg"];
        }
    }

    static fromJS(data: any): ErrorDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["errorType"] = this.errorType;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IErrorDTO {
    errorCode?: string | undefined;
    errorType?: string | undefined;
    errorMsg?: string | undefined;
}

export class AgencyGetAllResponse implements IAgencyGetAllResponse {
    result?: AgencyDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IAgencyGetAllResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AgencyDTO.fromJS(item));
            }
            this.total = _data["total"];
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgencyGetAllResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyGetAllResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAgencyGetAllResponse {
    result?: AgencyDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class AgencyGetByIdResponse implements IAgencyGetByIdResponse {
    data?: AgencyDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IAgencyGetByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AgencyDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgencyGetByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyGetByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAgencyGetByIdResponse {
    data?: AgencyDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class AgencyDeleteByIdResponse implements IAgencyDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IAgencyDeleteByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgencyDeleteByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyDeleteByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAgencyDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class AgencyUpdateRequest implements IAgencyUpdateRequest {
    agency?: AgencyDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IAgencyUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.agency = _data["agency"] ? AgencyDTO.fromJS(_data["agency"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AgencyUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agency"] = this.agency ? this.agency.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IAgencyUpdateRequest {
    agency?: AgencyDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class AgencyUpdateResponse implements IAgencyUpdateResponse {
    data?: AgencyDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IAgencyUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AgencyDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgencyUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgencyUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAgencyUpdateResponse {
    data?: AgencyDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class CaseTypeGetAllRequest implements ICaseTypeGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ICaseTypeGetAllRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.predicate = _data["predicate"] ? ViewPredicate.fromJS(_data["predicate"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CaseTypeGetAllRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeGetAllRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["predicate"] = this.predicate ? this.predicate.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface ICaseTypeGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class CaseTypeDTO implements ICaseTypeDTO {
    id?: number;
    caseType?: string | undefined;
    description?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: ICaseTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caseType = _data["caseType"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): CaseTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caseType"] = this.caseType;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface ICaseTypeDTO {
    id?: number;
    caseType?: string | undefined;
    description?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class CaseTypeGetAllResponse implements ICaseTypeGetAllResponse {
    result?: CaseTypeDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: ICaseTypeGetAllResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CaseTypeDTO.fromJS(item));
            }
            this.total = _data["total"];
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypeGetAllResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeGetAllResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICaseTypeGetAllResponse {
    result?: CaseTypeDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class CaseTypeGetByIdResponse implements ICaseTypeGetByIdResponse {
    data?: CaseTypeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: ICaseTypeGetByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CaseTypeDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypeGetByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeGetByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICaseTypeGetByIdResponse {
    data?: CaseTypeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class CaseTypeDeleteByIdResponse implements ICaseTypeDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: ICaseTypeDeleteByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypeDeleteByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeDeleteByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICaseTypeDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class CaseTypeUpdateRequest implements ICaseTypeUpdateRequest {
    caseType?: CaseTypeDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: ICaseTypeUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseType = _data["caseType"] ? CaseTypeDTO.fromJS(_data["caseType"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CaseTypeUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface ICaseTypeUpdateRequest {
    caseType?: CaseTypeDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class CaseTypeUpdateResponse implements ICaseTypeUpdateResponse {
    data?: CaseTypeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: ICaseTypeUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CaseTypeDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypeUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICaseTypeUpdateResponse {
    data?: CaseTypeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ContactGetAllRequest implements IContactGetAllRequest {
    predicate?: ViewPredicate;
    contactType?: string | undefined;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IContactGetAllRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.predicate = _data["predicate"] ? ViewPredicate.fromJS(_data["predicate"]) : <any>undefined;
            this.contactType = _data["contactType"];
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): ContactGetAllRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGetAllRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["predicate"] = this.predicate ? this.predicate.toJSON() : <any>undefined;
        data["contactType"] = this.contactType;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IContactGetAllRequest {
    predicate?: ViewPredicate;
    contactType?: string | undefined;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class ContactDTO implements IContactDTO {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    contactName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    contactType?: string | undefined;
    displayName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IContactDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.contactName = _data["contactName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.phone = _data["phone"];
            this.contactType = _data["contactType"];
            this.displayName = _data["displayName"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): ContactDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["contactName"] = this.contactName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["phone"] = this.phone;
        data["contactType"] = this.contactType;
        data["displayName"] = this.displayName;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IContactDTO {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    contactName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    contactType?: string | undefined;
    displayName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class ContactGetAllResponse implements IContactGetAllResponse {
    result?: ContactDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IContactGetAllResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ContactDTO.fromJS(item));
            }
            this.total = _data["total"];
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactGetAllResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGetAllResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactGetAllResponse {
    result?: ContactDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ContactGetByIdResponse implements IContactGetByIdResponse {
    data?: ContactDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IContactGetByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ContactDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactGetByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGetByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactGetByIdResponse {
    data?: ContactDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ContactDeleteByIdResponse implements IContactDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IContactDeleteByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactDeleteByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDeleteByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ContactUpdateRequest implements IContactUpdateRequest {
    contact?: ContactDTO;
    contactType?: string | undefined;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IContactUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"] ? ContactDTO.fromJS(_data["contact"]) : <any>undefined;
            this.contactType = _data["contactType"];
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): ContactUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["contactType"] = this.contactType;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IContactUpdateRequest {
    contact?: ContactDTO;
    contactType?: string | undefined;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class ContactUpdateResponse implements IContactUpdateResponse {
    data?: ContactDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IContactUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ContactDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactUpdateResponse {
    data?: ContactDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class DeveloperDTO implements IDeveloperDTO {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    contactName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    contactType?: string | undefined;
    displayName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IDeveloperDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.contactName = _data["contactName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.phone = _data["phone"];
            this.contactType = _data["contactType"];
            this.displayName = _data["displayName"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): DeveloperDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DeveloperDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["contactName"] = this.contactName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["phone"] = this.phone;
        data["contactType"] = this.contactType;
        data["displayName"] = this.displayName;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IDeveloperDTO {
    id?: number;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    contactName?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    contactType?: string | undefined;
    displayName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class DeveloperByPhaseResponse implements IDeveloperByPhaseResponse {
    data?: DeveloperDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IDeveloperByPhaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DeveloperDTO.fromJS(item));
            }
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeveloperByPhaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeveloperByPhaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeveloperByPhaseResponse {
    data?: DeveloperDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class DlmtCaseGetAllRequest implements IDlmtCaseGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IDlmtCaseGetAllRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.predicate = _data["predicate"] ? ViewPredicate.fromJS(_data["predicate"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): DlmtCaseGetAllRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtCaseGetAllRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["predicate"] = this.predicate ? this.predicate.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IDlmtCaseGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class CaseSearchDTO implements ICaseSearchDTO {
    caseId?: number;
    caseNumber?: string | undefined;
    caseType?: string | undefined;
    planningOffice?: string | undefined;
    area?: string | undefined;
    agency?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: ICaseSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseId = _data["caseId"];
            this.caseNumber = _data["caseNumber"];
            this.caseType = _data["caseType"];
            this.planningOffice = _data["planningOffice"];
            this.area = _data["area"];
            this.agency = _data["agency"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): CaseSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CaseSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseId"] = this.caseId;
        data["caseNumber"] = this.caseNumber;
        data["caseType"] = this.caseType;
        data["planningOffice"] = this.planningOffice;
        data["area"] = this.area;
        data["agency"] = this.agency;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface ICaseSearchDTO {
    caseId?: number;
    caseNumber?: string | undefined;
    caseType?: string | undefined;
    planningOffice?: string | undefined;
    area?: string | undefined;
    agency?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class DlmtCaseGetAllResponse implements IDlmtCaseGetAllResponse {
    result?: CaseSearchDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IDlmtCaseGetAllResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CaseSearchDTO.fromJS(item));
            }
            this.total = _data["total"];
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DlmtCaseGetAllResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtCaseGetAllResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDlmtCaseGetAllResponse {
    result?: CaseSearchDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ZoneAreaDTO implements IZoneAreaDTO {
    id?: number;
    zone?: string | undefined;
    name?: string | undefined;
    zoneName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IZoneAreaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.zone = _data["zone"];
            this.name = _data["name"];
            this.zoneName = _data["zoneName"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): ZoneAreaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneAreaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["zone"] = this.zone;
        data["name"] = this.name;
        data["zoneName"] = this.zoneName;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IZoneAreaDTO {
    id?: number;
    zone?: string | undefined;
    name?: string | undefined;
    zoneName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class PlanningOfficeDTO implements IPlanningOfficeDTO {
    id?: number;
    officeName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IPlanningOfficeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.officeName = _data["officeName"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): PlanningOfficeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlanningOfficeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["officeName"] = this.officeName;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IPlanningOfficeDTO {
    id?: number;
    officeName?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class DlmtNewCaseFormLookupResponse implements IDlmtNewCaseFormLookupResponse {
    caseTypes?: CaseTypeDTO[] | undefined;
    zoneAreas?: ZoneAreaDTO[] | undefined;
    agencies?: AgencyDTO[] | undefined;
    planningOffices?: PlanningOfficeDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IDlmtNewCaseFormLookupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["caseTypes"])) {
                this.caseTypes = [] as any;
                for (let item of _data["caseTypes"])
                    this.caseTypes!.push(CaseTypeDTO.fromJS(item));
            }
            if (Array.isArray(_data["zoneAreas"])) {
                this.zoneAreas = [] as any;
                for (let item of _data["zoneAreas"])
                    this.zoneAreas!.push(ZoneAreaDTO.fromJS(item));
            }
            if (Array.isArray(_data["agencies"])) {
                this.agencies = [] as any;
                for (let item of _data["agencies"])
                    this.agencies!.push(AgencyDTO.fromJS(item));
            }
            if (Array.isArray(_data["planningOffices"])) {
                this.planningOffices = [] as any;
                for (let item of _data["planningOffices"])
                    this.planningOffices!.push(PlanningOfficeDTO.fromJS(item));
            }
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DlmtNewCaseFormLookupResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtNewCaseFormLookupResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.caseTypes)) {
            data["caseTypes"] = [];
            for (let item of this.caseTypes)
                data["caseTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.zoneAreas)) {
            data["zoneAreas"] = [];
            for (let item of this.zoneAreas)
                data["zoneAreas"].push(item.toJSON());
        }
        if (Array.isArray(this.agencies)) {
            data["agencies"] = [];
            for (let item of this.agencies)
                data["agencies"].push(item.toJSON());
        }
        if (Array.isArray(this.planningOffices)) {
            data["planningOffices"] = [];
            for (let item of this.planningOffices)
                data["planningOffices"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDlmtNewCaseFormLookupResponse {
    caseTypes?: CaseTypeDTO[] | undefined;
    zoneAreas?: ZoneAreaDTO[] | undefined;
    agencies?: AgencyDTO[] | undefined;
    planningOffices?: PlanningOfficeDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class DlmtCaseSummaryDTO implements IDlmtCaseSummaryDTO {
    id?: number;
    agencyId?: number;
    caseNumber?: string | undefined;
    zoneAreaId?: number;
    planningOfficeId?: number;
    caseTypeId?: number;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IDlmtCaseSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.agencyId = _data["agencyId"];
            this.caseNumber = _data["caseNumber"];
            this.zoneAreaId = _data["zoneAreaId"];
            this.planningOfficeId = _data["planningOfficeId"];
            this.caseTypeId = _data["caseTypeId"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): DlmtCaseSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtCaseSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["agencyId"] = this.agencyId;
        data["caseNumber"] = this.caseNumber;
        data["zoneAreaId"] = this.zoneAreaId;
        data["planningOfficeId"] = this.planningOfficeId;
        data["caseTypeId"] = this.caseTypeId;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IDlmtCaseSummaryDTO {
    id?: number;
    agencyId?: number;
    caseNumber?: string | undefined;
    zoneAreaId?: number;
    planningOfficeId?: number;
    caseTypeId?: number;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class DlmtCaseSummaryUpdateRequest implements IDlmtCaseSummaryUpdateRequest {
    caseSummary?: DlmtCaseSummaryDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IDlmtCaseSummaryUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseSummary = _data["caseSummary"] ? DlmtCaseSummaryDTO.fromJS(_data["caseSummary"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): DlmtCaseSummaryUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtCaseSummaryUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseSummary"] = this.caseSummary ? this.caseSummary.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IDlmtCaseSummaryUpdateRequest {
    caseSummary?: DlmtCaseSummaryDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class DlmtCaseSummaryUpdateResponse implements IDlmtCaseSummaryUpdateResponse {
    data?: DlmtCaseSummaryDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IDlmtCaseSummaryUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DlmtCaseSummaryDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DlmtCaseSummaryUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtCaseSummaryUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDlmtCaseSummaryUpdateResponse {
    data?: DlmtCaseSummaryDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class DetailsFormLookupResponse implements IDetailsFormLookupResponse {
    caseTypes?: CaseTypeDTO[] | undefined;
    zoneAreas?: ZoneAreaDTO[] | undefined;
    agencies?: AgencyDTO[] | undefined;
    planningOffices?: PlanningOfficeDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IDetailsFormLookupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["caseTypes"])) {
                this.caseTypes = [] as any;
                for (let item of _data["caseTypes"])
                    this.caseTypes!.push(CaseTypeDTO.fromJS(item));
            }
            if (Array.isArray(_data["zoneAreas"])) {
                this.zoneAreas = [] as any;
                for (let item of _data["zoneAreas"])
                    this.zoneAreas!.push(ZoneAreaDTO.fromJS(item));
            }
            if (Array.isArray(_data["agencies"])) {
                this.agencies = [] as any;
                for (let item of _data["agencies"])
                    this.agencies!.push(AgencyDTO.fromJS(item));
            }
            if (Array.isArray(_data["planningOffices"])) {
                this.planningOffices = [] as any;
                for (let item of _data["planningOffices"])
                    this.planningOffices!.push(PlanningOfficeDTO.fromJS(item));
            }
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DetailsFormLookupResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DetailsFormLookupResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.caseTypes)) {
            data["caseTypes"] = [];
            for (let item of this.caseTypes)
                data["caseTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.zoneAreas)) {
            data["zoneAreas"] = [];
            for (let item of this.zoneAreas)
                data["zoneAreas"].push(item.toJSON());
        }
        if (Array.isArray(this.agencies)) {
            data["agencies"] = [];
            for (let item of this.agencies)
                data["agencies"].push(item.toJSON());
        }
        if (Array.isArray(this.planningOffices)) {
            data["planningOffices"] = [];
            for (let item of this.planningOffices)
                data["planningOffices"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDetailsFormLookupResponse {
    caseTypes?: CaseTypeDTO[] | undefined;
    zoneAreas?: ZoneAreaDTO[] | undefined;
    agencies?: AgencyDTO[] | undefined;
    planningOffices?: PlanningOfficeDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class DlmtCaseDetailsDTO implements IDlmtCaseDetailsDTO {
    id?: number;
    caseNumber?: string | undefined;
    caseTypeDsp?: string | undefined;
    caseTypeId?: number;
    planningOfficeId?: number;
    planningOfficeDsp?: string | undefined;
    zoneId?: number;
    zoneDsp?: string | undefined;
    agencyId?: number;
    agencyDsp?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IDlmtCaseDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caseNumber = _data["caseNumber"];
            this.caseTypeDsp = _data["caseTypeDsp"];
            this.caseTypeId = _data["caseTypeId"];
            this.planningOfficeId = _data["planningOfficeId"];
            this.planningOfficeDsp = _data["planningOfficeDsp"];
            this.zoneId = _data["zoneId"];
            this.zoneDsp = _data["zoneDsp"];
            this.agencyId = _data["agencyId"];
            this.agencyDsp = _data["agencyDsp"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): DlmtCaseDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtCaseDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caseNumber"] = this.caseNumber;
        data["caseTypeDsp"] = this.caseTypeDsp;
        data["caseTypeId"] = this.caseTypeId;
        data["planningOfficeId"] = this.planningOfficeId;
        data["planningOfficeDsp"] = this.planningOfficeDsp;
        data["zoneId"] = this.zoneId;
        data["zoneDsp"] = this.zoneDsp;
        data["agencyId"] = this.agencyId;
        data["agencyDsp"] = this.agencyDsp;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IDlmtCaseDetailsDTO {
    id?: number;
    caseNumber?: string | undefined;
    caseTypeDsp?: string | undefined;
    caseTypeId?: number;
    planningOfficeId?: number;
    planningOfficeDsp?: string | undefined;
    zoneId?: number;
    zoneDsp?: string | undefined;
    agencyId?: number;
    agencyDsp?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class CasePhaseDTO implements ICasePhaseDTO {
    id?: number;
    caseMainId?: number;
    phaseNo?: string | undefined;
    lots?: number;
    spaces?: number;
    grossAcres?: number;
    netAcres?: number;
    encrPermitExpected?: boolean;
    encrPermitNumber?: number;
    comment?: string | undefined;
    isActive?: boolean;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: ICasePhaseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caseMainId = _data["caseMainId"];
            this.phaseNo = _data["phaseNo"];
            this.lots = _data["lots"];
            this.spaces = _data["spaces"];
            this.grossAcres = _data["grossAcres"];
            this.netAcres = _data["netAcres"];
            this.encrPermitExpected = _data["encrPermitExpected"];
            this.encrPermitNumber = _data["encrPermitNumber"];
            this.comment = _data["comment"];
            this.isActive = _data["isActive"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): CasePhaseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CasePhaseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caseMainId"] = this.caseMainId;
        data["phaseNo"] = this.phaseNo;
        data["lots"] = this.lots;
        data["spaces"] = this.spaces;
        data["grossAcres"] = this.grossAcres;
        data["netAcres"] = this.netAcres;
        data["encrPermitExpected"] = this.encrPermitExpected;
        data["encrPermitNumber"] = this.encrPermitNumber;
        data["comment"] = this.comment;
        data["isActive"] = this.isActive;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface ICasePhaseDTO {
    id?: number;
    caseMainId?: number;
    phaseNo?: string | undefined;
    lots?: number;
    spaces?: number;
    grossAcres?: number;
    netAcres?: number;
    encrPermitExpected?: boolean;
    encrPermitNumber?: number;
    comment?: string | undefined;
    isActive?: boolean;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class DlmtDetailsFormDataResponse implements IDlmtDetailsFormDataResponse {
    mainCase?: DlmtCaseDetailsDTO;
    casePhases?: CasePhaseDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IDlmtDetailsFormDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainCase = _data["mainCase"] ? DlmtCaseDetailsDTO.fromJS(_data["mainCase"]) : <any>undefined;
            if (Array.isArray(_data["casePhases"])) {
                this.casePhases = [] as any;
                for (let item of _data["casePhases"])
                    this.casePhases!.push(CasePhaseDTO.fromJS(item));
            }
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DlmtDetailsFormDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtDetailsFormDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainCase"] = this.mainCase ? this.mainCase.toJSON() : <any>undefined;
        if (Array.isArray(this.casePhases)) {
            data["casePhases"] = [];
            for (let item of this.casePhases)
                data["casePhases"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDlmtDetailsFormDataResponse {
    mainCase?: DlmtCaseDetailsDTO;
    casePhases?: CasePhaseDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class DlmtDetailsPersonnelDataResponse implements IDlmtDetailsPersonnelDataResponse {
    developers?: DeveloperDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IDlmtDetailsPersonnelDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["developers"])) {
                this.developers = [] as any;
                for (let item of _data["developers"])
                    this.developers!.push(DeveloperDTO.fromJS(item));
            }
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DlmtDetailsPersonnelDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DlmtDetailsPersonnelDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.developers)) {
            data["developers"] = [];
            for (let item of this.developers)
                data["developers"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDlmtDetailsPersonnelDataResponse {
    developers?: DeveloperDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class PlanningOfficeGetAllRequest implements IPlanningOfficeGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IPlanningOfficeGetAllRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.predicate = _data["predicate"] ? ViewPredicate.fromJS(_data["predicate"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): PlanningOfficeGetAllRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PlanningOfficeGetAllRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["predicate"] = this.predicate ? this.predicate.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IPlanningOfficeGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class PlanningOfficeGetAllResponse implements IPlanningOfficeGetAllResponse {
    result?: PlanningOfficeDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IPlanningOfficeGetAllResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(PlanningOfficeDTO.fromJS(item));
            }
            this.total = _data["total"];
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlanningOfficeGetAllResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PlanningOfficeGetAllResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlanningOfficeGetAllResponse {
    result?: PlanningOfficeDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class PlanningOfficeGetByIdResponse implements IPlanningOfficeGetByIdResponse {
    data?: PlanningOfficeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IPlanningOfficeGetByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? PlanningOfficeDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlanningOfficeGetByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PlanningOfficeGetByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlanningOfficeGetByIdResponse {
    data?: PlanningOfficeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class PlanningOfficeDeleteByIdResponse implements IPlanningOfficeDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IPlanningOfficeDeleteByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlanningOfficeDeleteByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PlanningOfficeDeleteByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlanningOfficeDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class PlanningOfficeUpdateRequest implements IPlanningOfficeUpdateRequest {
    planningOffice?: PlanningOfficeDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IPlanningOfficeUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.planningOffice = _data["planningOffice"] ? PlanningOfficeDTO.fromJS(_data["planningOffice"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): PlanningOfficeUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PlanningOfficeUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["planningOffice"] = this.planningOffice ? this.planningOffice.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IPlanningOfficeUpdateRequest {
    planningOffice?: PlanningOfficeDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class PlanningOfficeUpdateResponse implements IPlanningOfficeUpdateResponse {
    data?: PlanningOfficeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IPlanningOfficeUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? PlanningOfficeDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlanningOfficeUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PlanningOfficeUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlanningOfficeUpdateResponse {
    data?: PlanningOfficeDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ReportMainDTO implements IReportMainDTO {
    id?: number;
    adpNumber?: string | undefined;
    adpName?: string | undefined;
    rate?: number;
    rateName?: string | undefined;
    effectiveDate?: Date;
    effectiveDateStr?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;

    constructor(data?: IReportMainDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adpNumber = _data["adpNumber"];
            this.adpName = _data["adpName"];
            this.rate = _data["rate"];
            this.rateName = _data["rateName"];
            this.effectiveDate = _data["effectiveDate"] ? new Date(_data["effectiveDate"].toString()) : <any>undefined;
            this.effectiveDateStr = _data["effectiveDateStr"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): ReportMainDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ReportMainDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adpNumber"] = this.adpNumber;
        data["adpName"] = this.adpName;
        data["rate"] = this.rate;
        data["rateName"] = this.rateName;
        data["effectiveDate"] = this.effectiveDate ? this.effectiveDate.toISOString() : <any>undefined;
        data["effectiveDateStr"] = this.effectiveDateStr;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["statusId"] = this.statusId;
        return data; 
    }
}

export interface IReportMainDTO {
    id?: number;
    adpNumber?: string | undefined;
    adpName?: string | undefined;
    rate?: number;
    rateName?: string | undefined;
    effectiveDate?: Date;
    effectiveDateStr?: string | undefined;
    createdBy?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    updatedBy?: string | undefined;
    statusId?: number;
}

export class ReportADPMainResponse implements IReportADPMainResponse {
    data?: ReportMainDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IReportADPMainResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ReportMainDTO.fromJS(item));
            }
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportADPMainResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReportADPMainResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReportADPMainResponse {
    data?: ReportMainDTO[] | undefined;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ZoneAreaGetAllRequest implements IZoneAreaGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IZoneAreaGetAllRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.predicate = _data["predicate"] ? ViewPredicate.fromJS(_data["predicate"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): ZoneAreaGetAllRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneAreaGetAllRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["predicate"] = this.predicate ? this.predicate.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IZoneAreaGetAllRequest {
    predicate?: ViewPredicate;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class ZoneAreaGetAllResponse implements IZoneAreaGetAllResponse {
    result?: ZoneAreaDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IZoneAreaGetAllResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ZoneAreaDTO.fromJS(item));
            }
            this.total = _data["total"];
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ZoneAreaGetAllResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneAreaGetAllResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IZoneAreaGetAllResponse {
    result?: ZoneAreaDTO[] | undefined;
    total?: number;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ZoneAreaGetByIdResponse implements IZoneAreaGetByIdResponse {
    data?: ZoneAreaDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IZoneAreaGetByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ZoneAreaDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ZoneAreaGetByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneAreaGetByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IZoneAreaGetByIdResponse {
    data?: ZoneAreaDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ZoneAreaDeleteByIdResponse implements IZoneAreaDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IZoneAreaDeleteByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ZoneAreaDeleteByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneAreaDeleteByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IZoneAreaDeleteByIdResponse {
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ZoneAreaUpdateRequest implements IZoneAreaUpdateRequest {
    zoneArea?: ZoneAreaDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IZoneAreaUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zoneArea = _data["zoneArea"] ? ZoneAreaDTO.fromJS(_data["zoneArea"]) : <any>undefined;
            this.currentUser = _data["currentUser"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): ZoneAreaUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneAreaUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zoneArea"] = this.zoneArea ? this.zoneArea.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IZoneAreaUpdateRequest {
    zoneArea?: ZoneAreaDTO;
    currentUser?: string | undefined;
    roles?: string[] | undefined;
}

export class ZoneAreaUpdateResponse implements IZoneAreaUpdateResponse {
    data?: ZoneAreaDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;

    constructor(data?: IZoneAreaUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ZoneAreaDTO.fromJS(_data["data"]) : <any>undefined;
            this.hasError = _data["hasError"];
            if (Array.isArray(_data["errorMsgs"])) {
                this.errorMsgs = [] as any;
                for (let item of _data["errorMsgs"])
                    this.errorMsgs!.push(ErrorDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ZoneAreaUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneAreaUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["hasError"] = this.hasError;
        if (Array.isArray(this.errorMsgs)) {
            data["errorMsgs"] = [];
            for (let item of this.errorMsgs)
                data["errorMsgs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IZoneAreaUpdateResponse {
    data?: ZoneAreaDTO;
    hasError?: boolean;
    errorMsgs?: ErrorDTO[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}